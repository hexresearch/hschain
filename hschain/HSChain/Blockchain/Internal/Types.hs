{-# LANGUAGE DataKinds            #-}
{-# LANGUAGE DeriveAnyClass       #-}
{-# LANGUAGE DeriveGeneric        #-}
{-# LANGUAGE DerivingStrategies   #-}
{-# LANGUAGE FlexibleContexts     #-}
{-# LANGUAGE FlexibleInstances    #-}
{-# LANGUAGE LambdaCase           #-}
{-# LANGUAGE OverloadedStrings    #-}
{-# LANGUAGE StandaloneDeriving   #-}
{-# LANGUAGE UndecidableInstances #-}
-- |
module HSChain.Blockchain.Internal.Types (
    MessageRx(..)
  , unverifyMessageRx
  , MessageTx(..)
  , EngineMessage(..)
  , Announcement(..)
    -- * Vote sets
  , VoteSet
  , newVoteSet
  , HeightVoteSet
  , newHeightVoteSet
    -- * State of tendermint consensus
  , ProposalState(..)
  , TMState(..)
  ) where

import Codec.Serialise        (Serialise)
import GHC.Generics           (Generic)
import qualified Data.Aeson          as JSON
import           Data.Map              (Map)
import qualified Data.HashMap.Strict as HM
import qualified Katip

import HSChain.Crypto
import HSChain.Crypto.Containers
import HSChain.Store.Internal.Proposals
import HSChain.Types.Blockchain
import HSChain.Types.Validators


----------------------------------------------------------------
-- Vote sets
----------------------------------------------------------------

type VoteSet ty a = SignedSet (Alg a) (Vote ty a) (Maybe (BlockID a))

type HeightVoteSet ty a = SignedSetMap Round (Alg a) (Vote ty a) (Maybe (BlockID a))

-- | Create new empty vote set
newVoteSet :: ValidatorSet (Alg a) -> VoteSet ty a
newVoteSet valSet = emptySignedSet valSet voteBlockID

-- | Create new empty vote set
newHeightVoteSet :: ValidatorSet (Alg a) -> HeightVoteSet ty a
newHeightVoteSet valSet = emptySignedSetMap valSet voteBlockID

----------------------------------------------------------------
-- State for of tendermint state machine
----------------------------------------------------------------

-- | Proposal state as seen by consensus algorithm
data ProposalState
  = GoodProposal
    -- ^ Proposal is valid and we could vote for it
  | InvalidProposal
    -- ^ Proposal is invalid for some reason
  | UnseenProposal
    -- ^ We don't have complete block data for particular block ID yet
  deriving stock    (Show, Eq, Generic)
  deriving anyclass (Serialise, JSON.FromJSON, JSON.ToJSON)

instance Katip.ToObject ProposalState where
  toObject p = HM.singleton "val" (JSON.toJSON p)
instance Katip.LogItem ProposalState where
  payloadKeys _ _ = Katip.AllKeys


-- | State for tendermint consensus at some particular height.
data TMState a = TMState
  { smRound          :: !Round
    -- ^ Current round
  , smStep           :: !Step
    -- ^ Current step in the round
  , smProposals      :: !(Map Round (Signed 'Verified (Alg a) (Proposal a)))
    -- ^ Proposal for current round
  , smProposedBlocks :: !(Props a)
    -- ^ Proposed blocks and their validation state
  , smPrevotesSet    :: !(HeightVoteSet 'PreVote a)
    -- ^ Set of all received valid prevotes
  , smPrecommitsSet  :: !(HeightVoteSet 'PreCommit a)
    -- ^ Set of all received valid precommits
  , smLockedBlock    :: !(Maybe (Round, BlockID a))
    -- ^ Round and block we're locked on
  , smLastCommit     :: !(Maybe (Commit a))                   -- TODO try strict Maybe
    -- ^ Commit for previous block. Nothing if previous block is
    --   genesis block.
  }


----------------------------------------------------------------
-- Messages
----------------------------------------------------------------

-- | Messages generated by consensus state machine
data EngineMessage a
  = EngTimeout       !Timeout
    -- ^ Signals that given block from given round should be accepted
  | EngCastPropose   !Round !(BlockID a) !(Maybe Round)
  | EngCastPreVote   !Round !(Maybe (BlockID a))
  | EngCastPreCommit !Round !(Maybe (BlockID a))
  | EngMisdeed       !(ByzantineEvidence a)
  | EngAnnPreVote    !(Signed 'Verified (Alg a) (Vote 'PreVote   a))
  | EngAnnPreCommit  !(Signed 'Verified (Alg a) (Vote 'PreCommit a))
  | EngAnnProposal  !Round
  | EngAnnStep       !FullStep
  | EngAnnLock       !(Maybe Round)
  deriving (Show,Generic)

-- | Message received by main application
data MessageRx ty a
  = RxPreVote   !(Signed ty (Alg a) (Vote 'PreVote   a))
  | RxPreCommit !(Signed ty (Alg a) (Vote 'PreCommit a))
  | RxProposal  !(Signed ty (Alg a) (Proposal a))
  | RxTimeout   !Timeout
  | RxBlock     !(Block a)
  deriving (Generic)
instance (CryptoHashable a, Serialise     a, Crypto (Alg a)) => Serialise     (MessageRx 'Unverified a)
instance (CryptoHashable a, JSON.FromJSON a, Crypto (Alg a)) => JSON.FromJSON (MessageRx 'Unverified a)
instance (JSON.ToJSON a, Crypto (Alg a)) => JSON.ToJSON (MessageRx ty a)
deriving stock instance (CryptoHash (Alg a), Show a) => Show (MessageRx ty a)

unverifyMessageRx :: MessageRx 'Verified a -> MessageRx 'Unverified a
unverifyMessageRx = \case
  RxPreVote   s -> RxPreVote   (unverifySignature s)
  RxPreCommit s -> RxPreCommit (unverifySignature s)
  RxProposal  s -> RxProposal  (unverifySignature s)
  RxTimeout   t -> RxTimeout   t
  RxBlock     b -> RxBlock     b

data MessageTx a
  = TxAnn       !(Announcement (Alg a))
  | TxPreVote   !(Signed 'Unverified (Alg a) (Vote 'PreVote   a))
  | TxPreCommit !(Signed 'Unverified (Alg a) (Vote 'PreCommit a))
  | TxProposal  !(Signed 'Unverified (Alg a) (Proposal a))
  deriving (Show)

-- | Messages which should be delivered to peers immediately. Those
--   are control messages in gossip protocol. Actual proposals, votes
--   and blocks are delivered pure via gossip.
data Announcement alg
  = AnnStep         !FullStep
  | AnnHasProposal  !Height !Round
  | AnnHasBlock     !Height !Round
  | AnnHasPreVote   !Height !Round !(ValidatorIdx alg)
  | AnnHasPreCommit !Height !Round !(ValidatorIdx alg)
  | AnnLock         !(Maybe Round)
  deriving (Show,Generic)
instance Serialise (Announcement alg)
