-- |HSChain.PoW.UTXO.Store
--
-- Incremental store management.
--
-- Copyright (C) ...

{-# LANGUAGE AllowAmbiguousTypes, DeriveGeneric, FlexibleContexts
           , OverloadedStrings, RankNTypes, RecordWildCards
           , ScopedTypeVariables, TypeApplications, TypeFamilies
  #-}

module HSChain.PoW.UTXO.Store where

import Control.Applicative
import Control.Lens
import Control.Monad

import Database.SQLite.Simple            ((:.)(..))
import qualified Database.SQLite.Simple as SQL
import qualified Database.SQLite.Simple.ToRow as SQL
import qualified Database.SQLite.Simple.ToField as SQL

import Data.Generics.Product.Typed (typed)

import Data.Int

import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map

import Data.String

import GHC.Generics

import HSChain.PoW.Store
import HSChain.PoW.Types
import HSChain.Store.Query

class ( SQL.ToRow (UTXO bdata)
      , SQL.ToRow (BlockID bdata)
      , SQL.ToField (BlockID bdata)
      ) => UTXOable (bdata :: (* -> *) -> *) where

  -- |The type of UTXO associated with the block data and transactions.
  type UTXO bdata

  -- |The type of unspent UTXO information associated with block data.
  type Unspent bdata

  -- |Prefix for table names.
  utxoTablesPrefix :: BH bdata -> String


-- | In-memory overlay for coin state. It contain changes to UTXO set
--   that are not commited to the database.
--
--   Note that it only contains block that are added to blockchain but
--   not rollbacks since latter are already commited.
data StateOverlay bdata
  = OverlayBase  (BH bdata)
  | OverlayLayer (BH bdata) (Layer bdata) (StateOverlay bdata)

-- | Overlay that is guaranteed to have layer to add UTXOs
data ActiveOverlay bdata = ActiveOverlay (Layer bdata) (StateOverlay bdata)
  deriving Generic

-- | Changes to database set generated by single block
data Layer (bdata :: (* -> *) -> *) = Layer
  { utxoCreated :: Map (UTXO bdata) (Unspent bdata)
  , utxoSpent   :: Map (UTXO bdata) (Unspent bdata)
  }

lensCreated, lensSpent :: Lens' (Layer bdata) (Map (UTXO bdata) (Unspent bdata))
lensCreated = lens utxoCreated (\m x -> m { utxoCreated = x })
lensSpent   = lens utxoSpent   (\m x -> m { utxoSpent   = x })

-- | Change to UTXO set
data Change a
  = Added a
  | Spent a

-- | Create empty overlay build over given block. It correspond to
--   state after evaluation of that block.
emptyOverlay :: BH bdata -> StateOverlay bdata
emptyOverlay = OverlayBase

-- | Get pointer to block index to block over which overlay is built.
overlayBase :: StateOverlay bdata -> BH bdata
overlayBase (OverlayBase  bh)    = bh
overlayBase (OverlayLayer _ _ o) = overlayBase o

overlayTip :: StateOverlay bdata -> BH bdata
overlayTip (OverlayBase  bh)     = bh
overlayTip (OverlayLayer bh _ _) = bh

-- | Roll back overlay by one block. Will throw if rolling past
--   genesis is attempted.
rollbackOverlay :: StateOverlay bdata -> StateOverlay bdata
rollbackOverlay (OverlayBase bh0) = case bhPrevious bh0 of
  Just bh -> OverlayBase bh
  Nothing -> error "Cant rewind overlay pas genesis"
rollbackOverlay (OverlayLayer _ _ o) = o

finalizeOverlay :: (Eq (BlockID bdata)) => BH bdata -> ActiveOverlay bdata -> Maybe (StateOverlay bdata)
finalizeOverlay bh (ActiveOverlay l o) = do
  bid <- bhBID <$> bhPrevious bh
  guard $ bhBID (overlayTip o) == bid
  pure  $ OverlayLayer bh l o

-- | Find whether given UTXO is awaialble to be spent or spent
--   already. We need latter since UTXO could be available in
--   underlying state but spent in overlay and we need to account for
--   that explicitly.
getOverlayUTXO :: Ord (UTXO bdata) => ActiveOverlay bdata -> UTXO bdata -> Maybe (Change (Unspent bdata))
getOverlayUTXO (ActiveOverlay l0 o0) utxo
  =  getFromLayer l0
 <|> recur o0
 where
   recur (OverlayBase  _)     = Nothing
   recur (OverlayLayer _ l o) =  getFromLayer l
                             <|> recur o
   getFromLayer Layer{..}
     =  Spent <$> Map.lookup utxo utxoSpent
    <|> Added <$> Map.lookup utxo utxoCreated

spendUTXO :: UTXO bdata -> Unspent bdata -> ActiveOverlay bdata -> ActiveOverlay bdata
spendUTXO utxo val
  = typed . lensSpent . at utxo .~ Just val

createUTXO :: forall bdata . UTXO bdata -> Unspent bdata -> ActiveOverlay bdata -> ActiveOverlay bdata
createUTXO utxo val
  = typed . lensCreated . at utxo .~ Just val

dumpOverlay :: (MonadQueryRW m, UTXOable bdata) => StateOverlay bdata -> m ()
dumpOverlay (OverlayLayer bh Layer{..} o) = do
  dumpOverlay o
  -- Store create UTXO
  forM_ (Map.toList utxoCreated) $ \(utxo, unspent) -> do
    basicExecute
      (fromString $ "INSERT OR IGNORE INTO "++utxoTablesPrefix bh++"_utxo VALUES (NULL,?,?,?,?)")
      (utxo :. unspent)
  -- Write down block delta
  bid <- retrieveBlockTableID bh
  forM_ (Map.keys utxoCreated) $ \utxo -> do
    uid <- retrieveUtxoIO bh utxo
    basicExecute
      (fromString $ "INSERT OR IGNORE INTO "++utxoTablesPrefix bh++"_utxo_created VALUES (?,?)")
      (bid, uid)
  forM_ (Map.keys utxoSpent) $ \utxo -> do
    uid <- retrieveUtxoIO bh utxo
    basicExecute
      (fromString $ "INSERT OR IGNORE INTO "++utxoTablesPrefix bh++"_utxo_spent VALUES (?,?)")
      (bid, uid)
dumpOverlay OverlayBase{} = return ()

revertBlockDB :: (MonadQueryRW m, UTXOable bdata) => BH bdata -> m ()
revertBlockDB bh = do
  i <- retrieveBlockTableID bh
  basicExecute
    (fromString $ "DELETE FROM "++utxoTablesPrefix bh++"_state WHERE live_utxo IN \
    \  (SELECT utxo_ref FROM "++utxoTablesPrefix bh++"_utxo_created WHERE block_ref = ?)")
    (Only i)
  basicExecute
    (fromString $ "INSERT OR IGNORE INTO "++utxoTablesPrefix bh++"_state \
    \  SELECT utxo_ref FROM "++utxoTablesPrefix bh++"_utxo_spent WHERE block_ref = ?")
    (Only i)

retrieveBlockTableID :: (MonadQueryRO m, UTXOable bdata) => BH bdata -> m (ID (Block bdata))
retrieveBlockTableID bh = do
  let bid = bhBID bh
  r <- basicQuery1
    (fromString $ "SELECT blk_id FROM "++utxoTablesPrefix bh++"_blocks WHERE bid =?")
    (Only bid)
  case r of
    Nothing       -> error "Unknown BID"
    Just (Only i) -> return i

retrieveUtxoIO :: (MonadQueryRO m, UTXOable bdata) => BH bdata -> UTXO bdata -> m Int64
retrieveUtxoIO bh utxo = do
  r <- basicQuery1
    (fromString $ "SELECT utxo_id FROM "++utxoTablesPrefix bh++"_utxo WHERE n_out = ? AND tx_hash = ?")
    utxo
  case r of
    Just (Only i) -> return i
    Nothing       -> error "retrieveUtxoIO"


