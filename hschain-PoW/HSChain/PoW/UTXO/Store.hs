-- |HSChain.PoW.UTXO.Store
--
-- Incremental store management.
--
-- Copyright (C) ...

module HSChain.PoW.UTXO.Store where

-- | In-memory overlay for coin state. It contain changes to UTXO set
--   that are not commited to the database.
--
--   Note that it only contains block that are added to blockchain but
--   not rollbacks since latter are already commited.
data StateOverlay bdata
  = OverlayBase  (BH bdata)
  | OverlayLayer (BH bdata) (Layer bdata) (StateOverlay bdata)

-- | Overlay that is guaranteed to have layer to add UTXOs
data ActiveOverlay bdata = ActiveOverlay (Layer bdata) (StateOverlay bdata)
  deriving Generic

-- | Changes to database set generated by single block
data Layer bdata = Layer
  { utxoCreated :: Map (UTXO bdata) (Unspent bdata)
  , utxoSpent   :: Map (UTXO bdata) (Unspent bdata)
  }

lensCreated, lensSpent :: Lens' Layer (Map (UTXO bdata) (Unspent bdata))
lensCreated = lens utxoCreated (\m x -> m { utxoCreated = x })
lensSpent   = lens utxoSpent   (\m x -> m { utxoSpent   = x })

-- | Change to UTXO set
data Change a
  = Added a
  | Spent a

-- | Create empty overlay build over given block. It correspond to
--   state after evaluation of that block.
emptyOverlay :: BH bdata -> StateOverlay bdata
emptyOverlay = OverlayBase

-- | Get pointer to block index to block over which overlay is built.
overlayBase :: StateOverlay -> BH Coin
overlayBase (OverlayBase  bh)    = bh
overlayBase (OverlayLayer _ _ o) = overlayBase o

overlayTip :: StateOverlay -> BH Coin
overlayTip (OverlayBase  bh)     = bh
overlayTip (OverlayLayer bh _ _) = bh

-- | Roll back overlay by one block. Will throw if rolling past
--   genesis is attempted.
rollbackOverlay :: StateOverlay -> StateOverlay
rollbackOverlay (OverlayBase bh0) = case bhPrevious bh0 of
  Just bh -> OverlayBase bh
  Nothing -> error "Cant rewind overlay pas genesis"
rollbackOverlay (OverlayLayer _ _ o) = o

finalizeOverlay :: BH Coin -> ActiveOverlay -> Maybe StateOverlay
finalizeOverlay bh (ActiveOverlay l o) = do
  bid <- bhBID <$> bhPrevious bh
  guard $ bhBID (overlayTip o) == bid
  pure  $ OverlayLayer bh l o

-- | Find whether given UTXO is awaialble to be spent or spent
--   already. We need latter since UTXO could be available in
--   underlying state but spent in overlay and we need to account for
--   that explicitly.
getOverlayUTXO :: ActiveOverlay -> UTXO -> Maybe (Change Unspent)
getOverlayUTXO (ActiveOverlay l0 o0) utxo
  =  getFromLayer l0
 <|> recur o0
 where
   recur (OverlayBase  _)     = Nothing
   recur (OverlayLayer _ l o) =  getFromLayer l
                             <|> recur o
   getFromLayer Layer{..}
     =  Spent <$> Map.lookup utxo utxoSpent
    <|> Added <$> Map.lookup utxo utxoCreated

spendUTXO :: UTXO -> Unspent -> ActiveOverlay -> ActiveOverlay
spendUTXO utxo val
  = typed . lensSpent . at utxo .~ Just val

createUTXO :: UTXO -> Unspent -> ActiveOverlay -> ActiveOverlay
createUTXO utxo val
  = typed . lensCreated . at utxo .~ Just val

dumpOverlay :: MonadQueryRW m => StateOverlay -> m ()
dumpOverlay (OverlayLayer bh Layer{..} o) = do
  dumpOverlay o
  -- Store create UTXO
  forM_ (Map.toList utxoCreated) $ \(utxo, unspent) -> do
    basicExecute
      "INSERT OR IGNORE INTO coin_utxo VALUES (NULL,?,?,?,?)"
      (utxo :. unspent)
  -- Write down block delta
  bid <- retrieveCoinBlockTableID (bhBID bh)
  forM_ (Map.keys utxoCreated) $ \utxo -> do
    uid <- retrieveUtxoIO utxo
    basicExecute
      "INSERT OR IGNORE INTO coin_utxo_created VALUES (?,?)"
      (bid, uid)
  forM_ (Map.keys utxoSpent) $ \utxo -> do
    uid <- retrieveUtxoIO utxo
    basicExecute
      "INSERT OR IGNORE INTO coin_utxo_spent VALUES (?,?)"
      (bid, uid)
dumpOverlay OverlayBase{} = return ()

revertBlockDB :: MonadQueryRW m => BH Coin -> m ()
revertBlockDB bh = do
  i <- retrieveCoinBlockTableID $ bhBID bh
  basicExecute
    "DELETE FROM coin_state WHERE live_utxo IN \
    \  (SELECT utxo_ref FROM coin_utxo_created WHERE block_ref = ?)"
    (Only i)
  basicExecute
    "INSERT OR IGNORE INTO coin_state \
    \  SELECT utxo_ref FROM coin_utxo_spent WHERE block_ref = ?"
    (Only i)

